# 第5章 メモリの仕組みの理解はプログラマのたしなみ

- スレッド
- 仮想マシン
- 静的領域
- ヒープ領域
- スタック領域
- ポインタ
- メソッドテーブル

## コンパイラとインタプリタの2つの実行方式

- プログラムの実行方式にはコンパイラ方式とインタプリタ方式の2つがある。
  - コンパイラ方式は実行効率が良く、インタプリタ方式では同じプログラムを異なる環境で動かすことができる。
- 中間コード方式により、同じプログラムを異なる実行環境で効率良く動かすことができる。

どちらも一長一短がある。ケースバイケースで採用する。

- コンパイラ方式： プログラムに書かれた命令をコンピュータが理解できる機械語に変換してから実行する。
  - 特定のマシン環境を前提としたアプリケーション。政府や銀行のシステムなど。
- インタプリタ方式： ソースコードに書かれたプログラムの命令をその場で逐次解釈しながら実行する。（実行はマシン環境に合うように解釈される）
  - インターネットを経由してさまざまなマシンで動くソフトウェア。
- 中間コード方式： Java。コンパイラを使って、ソースコードを特定の機械語に依存しない中間コードに変換する。そして、専用のインタプリタによって解釈して実行する

## 中間コードを解釈して実行する仮想マシン

- JVM(Java Virtual Machine)
  - 仮想マシン

## CPUは複数のスレッドを掛け持ちで実行する

- スレッド：プログラムの実行単位。「糸」「命の糸」。Webブラウザのリクエスト処理や「中止」ボタンの処理。
- プロセス：メーラーやWebブラウザ、表計算ソフトなど。複数のスレッドを持つ。
- マルチスレッドに処理することで、CPUリソースを効率的に利用できる。

- マルチスレッド環境
  - CPUが一時点で実行できる処理は1つのみ。CPUはミリ秒単位で1つのスレッドを実行し、スレッドの処理が中途半端な状態であっても、いったん中断し、次の処理に移る。処理速度が速いため、利用者は複数の仕事を同時に実行しているように見える。(知らなかった)

## 静的領域、ヒープ領域、スタック領域で管理

- プログラムのメモリ領域は、静的領域、ヒープ領域、スタック領域の3つに分けて管理する
- メソッドに書かれたコード情報は1クラスに1つだけロードされる

一般的なメモリの使われ方。メモリ領域は3つに分けて管理される。

- 静的領域
  - 概要： プログラムの開始時に確保され、以降プログラムが終了するまで配置が固定される領域のこと
    - 使い方： アプリケーション開始時に確保する
    - 格納： グローバル変数、実行コード
    - 単位： アプリケーションでまとめて1つ
- ヒープ領域
  - 概要： プログラムの実行時に動的に確保するためのメモリ領域。英語のheapは「たくさん」「山ほど」の意味を持つ。
    - 使い方： 開始時に一定領域を確保し、必要の都度アプリケーションに割り当てる
    - 格納： 任意
    - 単位： システムまたはアプリケーションで1つ
- スタック領域
  - 概要： スレッドの制御のために使うメモリ領域。スレッドに1つずつ用意される。OOPではメソッドを次々と呼び出すことで動作する
    - 使い方： Last In First Out
    - 格納： サブルーチンの引数やローカル変数、戻り先などの情報
    - 単位： スレッドごとに1つ

## クラス情報はクラスにつき1つだけロードされる

- クラス情報のロードのタイミング
  - 最初にすべてロードする： C++など
  - 実行時にロードする： Java、.Netなど

- Java
  - メソッドエリア(静的領域)
  - ヒープ領域
  - スタック領域

## インスタンス生成のたびにヒープ領域が使われる

- OOPで書いたプログラムは、有限のメモリ領域であるヒープ領域を大量に使って動く

インスタンスはヒープ領域に割り当てられる。インスタンス群は、メソッドエリアにあるクラス情報に対応づけられる。

## 変数にはインスタンスの「ポインタ」が格納される

- インスタンスを格納する変数にはインスタンスそのものではなく、インスタンスの「ポインタ」が格納される

変数の種類は様々であり、ヒープ領域にあるとは限らない。変数には、ヒープ領域に作られたインスタンスのポインタが格納される。

``TextFileReader reader = new TextFileReader();``

ポインタ：「メモリ領域の場所を示す情報」のこと。土地と住所に例えられる。(Javaではポインタではなく、参照と呼ぶ)

## インスタンスを格納する変数のコピーに要注意

- 変数にはインスタンスそのものではなく、インスタンスのポインタが格納される
- インスタンスを格納する変数を他の変数に代入した場合、ポインタがコピーされるだけで、ヒープ領域にあるインスタンスそのものは変化しない

## ポリモーフィズムは異なるクラスが同じ顔を見せる

ポリモーフィズムを実現するメモリ

- メソッドテーブル： メソッドのポインタを格納したもの

- 準備
  - メソッドテーブルを用意する
  - メソッドテーブルの形式をクラス間で統一する(親子で形式を統一する)


ヒープ領域のインスタンスは、メソッドエリアの統一されたメソッドテーブルを経由して、メソッドを実行する。こうすることで、ポリモーフィズムによって、メソッド内容が異なっていても、同じスーパークラスを持つクラスを、同じように呼び出すことができる

## 継承される情報によってメモリ配置は異なる

- スーパークラスから継承したメソッドとインスタンス変数のメモリ配置はまったく異なる
- スーパークラスのインスタンス変数は、ヒープ領域にあるサブクラスのすべてのインスタンスにコピーして保持される

・共通のメソッドは、メソッドテーブルに定義されるが、スーパークラスのメモリ領域から利用される
・ヒープ領域のインスタンスのインスタンス変数は、スーパークラスのものがコピーされている

```java
class Person {
  private String name;  // インスタンス変数、名前。
  public void setName(String nm) {  // 名前の設定
    this.name = nm;
  }
  public String getName() {  // 名前の取得
    return this.name;
  }
}

class Employee extends Person { // Personを継承したEmployeeクラス
  private int employeeNo; // インスタンス変数、社員番号
  public void setEmployeeNo(int empNO) { } 
  public int getEmployeeNO() { }
}
```

## 孤立したインスタンスはガベージコレクタが処分する

ガベージコレクタ：ガベージコレクションを実行する。ガベージコレクタは「孤立したインスタンス」を不要なインスタンスと判断する

OOPで書かれたアプリは、インスタンスが参照し合うネットワークを構成する。

- インスタンスのネットワークは、ヒープ領域だけではなく、スタックやメソッドエリアでも重要な役目を果たす
  - スタック： 引数やローカル変数に、インスタンス(のポインタ)を指定することもできる
  - メソッドエリア： ヒープ領域のインスタンスを参照できる
- スタックとメソッドエリアはアプリケーション処理で必要な情報であり、ここから参照されたインスタンスはガベージコレクションの対象にはならない
  - インスタンスネットワークの「根元」と言える

「不要になったインスタンスをスタックやメソッドエリアから参照し続けないこと」が、メモリ不足を見直すときのポイントと言える