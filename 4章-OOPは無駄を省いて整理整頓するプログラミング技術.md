# 第4章 OOPは無駄を省いて整理整頓するプログラミング言語

## OOP三大要素

- OOP三大要素
  - クラス
  - ポリモーフィズム
  - 継承

- OOPが解決する課題
  - グローバル変数を使わないで済む
  - 共通サブルーチン以外にも再利用を可能にする

## クラス

- クラスの効能
- クラスとは「まとめて、隠して、たくさん作る」仕組みのこと
  1. 関数と変数を「まとめる」
  2. クラスの内部だけで使う変数や関数を「隠す」
  3. 1つのクラスからインスタンスを「たくさん作る」

### まとめる

```java
// インスタンス変数：アクセス中のファイル番号
int fileNo;

void openFile(String pathName) { }

void closeFile() { }

char readFile() { // ファイルから1文字読み込む}
```

以上は、クラスを使って以下のようにまとめられる。

```java
class TextFileReader {
int fileNo;

void openFile(String pathName) { }

void closeFile() { }

char readFile() { /* ファイルから1文字読み込む */ }
}
```

- まとめるメリット
  - 部品の数が減る
  - 命名が楽になる
  - メソッドが探しやすい

### 隠す

ファイルナンバーをプライベートにし、このクラスだけで使えるものにする

```java
class TextFileReader {
private int fileNo;

void openFile(String pathName) { }

void closeFile() { }

char readFile() { /* ファイルから1文字読み込む */ }
}
```

メソッドを明示的に公開する

```java
public class TextFileReader {
private int fileNo;

public void openFile(String pathName) { }

public void closeFile() { }

public char readFile() { /* ファイルから1文字読み込む */ }
}
```

- 隠せるメリット
  - プログラムの保守性悪化の元凶となるグローバル変数を使わずにプログラムが書ける

### たくさん作る

OOP特有の機能

1つのクラスで複数のものを扱いたいが、変数はひとつしかない...？

-> クラスは、1つのクラスから複数のインスタンスを作れることができる。

インスンタスとは、クラスで定義したインスタンス変数が確保されるメモリ領域と考える。(つまり有限)。

クラスを定義しておけば、インスンタンスは(当然、メモリが許す限り)何個でもメモリ領域を確保できる。

```java
TextFileReader reader1 = new TextFileReader();
TextFileReader reader2 = new TextFileReader();

reader1.open("C：¥¥aaa.txt");
reader2.open("C：¥¥bbb.txt");

char ch; // 文字を読み込む変数の宣言
ch = reader1.read();
ch = reader2.read();
ch = reader1.read();

reader1.close();
reader2.close();
```

1つのクラスから複数のインスタンスを作ることができる。そうなると、メソッドの呼び出しは、どのインスタンスを呼び出すのか明示する必要がある。

``reader1.open("C：¥¥aaa.txt");``

この「たくさん作る」機能があるからこそ、クラス側にはインスタンス変数ひとつ置いておけば済み、配列などを使って変数領域を作る必要もなくなった。

- たくさん作れるメリット
  - クラスを定義しておけば、実行時にいくつでもインスタンスを作ることができる
  - 同種の情報を複数同時に扱う処理であっても、そのクラス内部のロジックをシンプルに書ける

## インスタンス変数

インスタンス変数の性質

インスタンス変数は、グローバル変数とローカル変数のいいところどりをした仕組み。(「長持ちするローカル変数」であり「仲間内だけのグローバル変数」)

- 複数サブルーチンからのアクセス
- アクセス可能範囲の限定
- 存在期間の長さ
- 変数領域の複製

加えて、インスタンス変数は、グローバル変数のように唯一無二の存在としてあらゆるものに影響し続けるのではなく、必要に応じてその都度作ることができる

## ポリモーフィズム

ポリモーフィズム：いろいろな形に変わる、多態性、多相性、(抽象的なもの)

ポリモーフィズムとは、「共通メインルーチンを作るための仕組み」。サブルーチンを呼び出す側のロジックを一本化してくれる。

このポリモーフィズムが登場したことで、フレームワークやクラスライブラリといった大規模な再利用品群の開発が可能になった。(共通メインルーチンのおかげで膨大なサブルーチンの統合が可能になり、構造化ができるようになった？)

ポリモーフィズムの準備

```java
// ネットワーク経由で送信された文字列を読み込むクラス
public class NetworkReader extends TextReader {
  public void open() { }

  public void close() { }

  public char read() { }
}
```

```java
// テキストファイルの文字列を読み込むクラス
public class TextFileReader extends TextReader {
  private int fileNO;

  public TextFileReader(String pathName) { } // 形式を統一するためopenメソッドの引数を、インスタンス化のコンストラクタ引数とする

  public void open() { }

  public void close() { }

  public char read() { }
}
```

```java
// 共通メインルーチン側
public class TextReader {

  public void open() { }

  public void close() { }

  public char read() { }
}
```

ポリモーフィズムの利用

```java
int getCount(TextReader reader || NetworkReader) {
  int charCount = 0;
  while (true) {
    char = reader.read();
    charCount++;
  }
  return charCount;
}
```

呼び出される側が増えても共通メインルーチンは修正しなくてよい。再利用品群が膨大になったとしても、構造化が可能。

## 継承

継承とは、「クラス定義の共通部分を別クラスにまとめる仕組み。コードの重複を排除できる」

### OOP三大要素のまとめ

- クラス
  - 説明：サブルーチンと変数をまとめてソフトウェア部品を作る
  - 目的：整理整頓
  - 要約：まとめて、隠して、たくさん作る仕組み
- ポリモーフィズム
  - 説明：メソッドを呼び出す側を共通化する
  - 目的：無駄を省く
  - 要約：共通メインルーチンを作る仕組み
- 継承
  - 説明：重複するクラス定義を共通化する
  - 目的：無駄を省く
  - 要約：クラスの共通部分を別クラスにまとめる仕組み

## 型

なぜ、型を指定するのか？

1. コンパイラにメモリ領域の大きさを教えることで、コンパイラが必要なメモリ容量の計算ができるようにするため
2. プログラムのエラーを防止するため。明示的にエラーを表示できる。

### クラスを型として利用する

OOPでは、型の仕組みをさらに推し進めて、クラスを型として扱うことができるようになった。

```java
// 変数の型にクラスを指定する
TextFileReader reader;

// メソッドの引数の型にクラスを指定する
int getCount(TextReader reader) { }

// メソッドの戻り値の型にクラスを指定する
TextReader getDefaultReader() { }
```

変数やメソッド、戻り値で、型のチェックができるようになった。

```java
// 変数の型にクラスを指定する
TextFileReader reader;
reader = 100; // コンパイルエラー
reader = new NetworkReader(); // コンパイルエラー
reader = new TextFileReader(); // コンパイルOK

// メソッドの引数や戻り値に対する型チェック
obj.getCount(new JLabel()); // コンパイルエラー(引数の型が不正)

TextReader getDefaultReader() {
  return new JButton(); // コンパイルエラー(戻り値の値が不正)
}
```

- 型チェックの仕組み
  - 強い型付け：Java、C#
  - 弱い型付け：Ruby、Smalltalk

### 言語仕様の退化

プログラミング言語の進化につれて、不要な機能は仕様不可になっていった。(GOTO文、マクロ、明示的なポインタ、グローバル変数)

## 進化したOOPの仕組み

- パッケージ
- 例外
- ガベージコレクション

### パッケージ

パッケージは、クラスをさらにまとめるもの

パッケージのメリット
  - 膨大なアプリケーションを数十個のパッケージにまとめて構造化できる 
  - クラスの名前の重複を全世界で避けられる

### 例外

例外は、「戻り値とは違う形式で、メソッドから特別なエラーを返す仕組み」

従来は、障害に対応するために、エラーコードを使用していた。(1のときはデッドロック、2のときは通信障害、3のときはその他...)

- エラーコードの問題点
  - エラーコードの判定処理を必ず書かなくてはいけない。抜けてたらすべて調べ直して書き直す必要がある(エラー処理のエラーを教えてくれる機能がない)
  - エラーコードを判定するロジックがサブルーチンの間で連鎖する(エラーを判定するためのサブルーチンのエラーを判定するためのサブルーチン)

- 例外のメリット
  - 例外の宣言や後処理を書き忘れた場合、コンパイルあるいは実行時にエラーになる
  - 後処理の必要がないメソッドでは例外の宣言だけをしておけばよい(エラー処理は一箇所にまとまる)

### ガベージコレクション

インスタンスにはメモリ領域が確保されるが、従来は、不要になったメモリ領域をプログラマが明示的に指示して削除する必要があった。(C、C++)

- 問題点
  - 削除したインスタンスが別の場所で使われていた場合は不正な動作をしてしまう
  - 不要なのに削除されていないインスタンスが増えてメモリが圧迫(メモリワーク)されてしまう

- ガベージコレクションのメリット
  - システムが用意する専用のプログラムが自動で削除してくれる
  - メモリの解放処理をしなくてよい

### OOPの進化のまとめ

高級言語までの進化： 命令の恒久化による表現力の向上、サブルーチンによる重複ロジックの削除
構造化言語までの進化： 基本三構造やGOTOレスプログラミング、サブルーチンの独立性を高める仕組みの導入
OOPの進化： 保守性の向上。部品化や再利用の機能を強化

### この章で学んだこと

```
OOPは「プログラミングの構造化」を目的にする。全体と部分を明確に区分し、整理整頓の方法を提供してくれる。

クラスは、独立した部品の集合体と、その部品をまとめるための機能を持っている。ポリモーフィズムは、抽象的な枠組みを用意することで、基盤を修正せずに多くの部品を量産できるようにしてくれる。継承によって、重複を排除できる。

さらに、パッケージによってもう一層超えたところで構造化を実現できる。例外によって、エラー処理を一元化し、ガベージコレクションによって、メモリの解放処理の負担を軽減した。

インスタンス変数は、ローカル変数とグローバル変数の中間的な変数で、範囲を限定し期間を設けつつ(制限をかけつつ)、複製やアクセスを行える。
また、型付けによって、エラーを未然に防ぐ体制を整えた。

- OOPの三大要素
  - クラス
  - ポリモーフィズム
  - 継承
- OOPの進化
  - パッケージ
  - 例外
  - ガベージコレクション
- インスタンス変数
- 型

以上のようなOOPの進化は、構造化言語以降の、保守性、部品化、再利用性の向上が目的としてあった。
```